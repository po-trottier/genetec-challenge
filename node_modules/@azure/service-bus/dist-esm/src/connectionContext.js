// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as log from "./log";
import * as os from "os";
import { packageJsonInfo } from "./util/constants";
import { Constants, ConnectionContextBase, delay } from "@azure/amqp-common";
import { ConnectionEvents } from "rhea-promise";
/**
 * @internal
 */
export var ConnectionContext;
(function (ConnectionContext) {
    /**
     * @property {string} userAgent The user agent string for the ServiceBus client.
     * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
     */
    ConnectionContext.userAgent = `azsdk-js-azureservicebus/${packageJsonInfo.version} (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;
    function create(config, tokenProvider, options) {
        if (!options)
            options = {};
        const parameters = {
            config: config,
            tokenProvider: tokenProvider,
            dataTransformer: options.dataTransformer,
            isEntityPathRequired: false,
            connectionProperties: {
                product: "MSJSClient",
                userAgent: ConnectionContext.userAgent,
                version: packageJsonInfo.version
            }
        };
        // Let us create the base context and then add ServiceBus specific ConnectionContext properties.
        const connectionContext = ConnectionContextBase.create(parameters);
        connectionContext.clientContexts = {};
        let waitForConnectionRefreshResolve;
        let waitForConnectionRefreshPromise;
        Object.assign(connectionContext, {
            isConnectionClosing() {
                // When the connection is not open, but the remote end is open,
                // then the rhea connection is in the process of terminating.
                return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());
            },
            readyToOpenLink() {
                return __awaiter(this, void 0, void 0, function* () {
                    log.error(`[${this.connectionId}] Waiting until the connection is ready to open link.`);
                    // Check that the connection isn't in the process of closing.
                    // This can happen when the idle timeout has been reached but
                    // the underlying socket is waiting to be destroyed.
                    if (this.isConnectionClosing()) {
                        // Wait for the disconnected event that indicates the underlying socket has closed.
                        yield this.waitForDisconnectedEvent();
                    }
                    // Wait for the connection to be reset.
                    yield this.waitForConnectionReset();
                    log.error(`[${this.connectionId}] Connection is ready to open link.`);
                });
            },
            waitForDisconnectedEvent() {
                return new Promise((resolve) => {
                    log.error(`[${this.connectionId}] Attempting to reinitialize connection` +
                        ` but the connection is in the process of closing.` +
                        ` Waiting for the disconnect event before continuing.`);
                    this.connection.once(ConnectionEvents.disconnected, resolve);
                });
            },
            waitForConnectionReset() {
                // Check if the connection is currently in the process of disconnecting.
                if (waitForConnectionRefreshPromise) {
                    return waitForConnectionRefreshPromise;
                }
                return Promise.resolve();
            }
        });
        // Define listeners to be added to the connection object for
        // "connection_open" and "connection_error" events.
        const onConnectionOpen = (context) => {
            connectionContext.wasConnectionCloseCalled = false;
            log.connectionCtxt("[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.", connectionContext.connection.id, connectionContext.wasConnectionCloseCalled);
        };
        const disconnected = (context) => __awaiter(this, void 0, void 0, function* () {
            if (waitForConnectionRefreshPromise) {
                return;
            }
            waitForConnectionRefreshPromise = new Promise((resolve) => {
                waitForConnectionRefreshResolve = resolve;
            });
            const connectionError = context.connection && context.connection.error ? context.connection.error : undefined;
            if (connectionError) {
                log.error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, connectionError);
            }
            const contextError = context.error;
            if (contextError) {
                log.error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, contextError);
            }
            const state = {
                wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,
                numClients: Object.keys(connectionContext.clientContexts).length
            };
            // Clear internal map maintained by rhea to avoid reconnecting of old links once the
            // connection is back up.
            connectionContext.connection.removeAllSessions();
            // Close the cbs session to ensure all the event handlers are released.
            yield connectionContext.cbsSession.close();
            // Close the management sessions to ensure all the event handlers are released.
            for (const id of Object.keys(connectionContext.clientContexts)) {
                const clientContext = connectionContext.clientContexts[id];
                if (clientContext.managementClient) {
                    yield clientContext.managementClient.close();
                }
            }
            yield refreshConnection(connectionContext);
            waitForConnectionRefreshResolve();
            waitForConnectionRefreshPromise = undefined;
            // The connection should always be brought back up if the sdk did not call connection.close()
            // and there was atleast one sender/receiver link on the connection before it went down.
            log.error("[%s] state: %O", connectionContext.connectionId, state);
            if (!state.wasConnectionCloseCalled && state.numClients) {
                log.error("[%s] connection.close() was not called from the sdk and there were some " +
                    "clients. We should reconnect.", connectionContext.connection.id);
                yield delay(Constants.connectionReconnectDelay);
                // reconnect clients if any
                for (const id of Object.keys(connectionContext.clientContexts)) {
                    const clientContext = connectionContext.clientContexts[id];
                    log.error("[%s] calling detached on client '%s'.", connectionContext.connection.id, clientContext.clientId);
                    clientContext.onDetached(connectionError || contextError).catch((err) => {
                        log.error("[%s] An error occurred while reconnecting the sender '%s': %O.", connectionContext.connection.id, clientContext.clientId, err);
                    });
                }
            }
        });
        const protocolError = (context) => __awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                log.error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                log.error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        const error = (context) => __awaiter(this, void 0, void 0, function* () {
            if (context.connection && context.connection.error) {
                log.error("[%s] Error (context.connection.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.connection && context.connection.error);
            }
            if (context.error) {
                log.error("[%s] Error (context.error) occurred on the amqp connection: %O", connectionContext.connection.id, context.error);
            }
        });
        function refreshConnection(connectionContext) {
            return __awaiter(this, void 0, void 0, function* () {
                const originalConnectionId = connectionContext.connectionId;
                try {
                    yield cleanConnectionContext(connectionContext);
                }
                catch (err) {
                    log.error(`[${connectionContext.connectionId}] There was an error closing the connection before reconnecting: %O`, err);
                }
                // Create a new connection, id, locks, and cbs client.
                connectionContext.refreshConnection();
                addConnectionListeners(connectionContext.connection);
                log.error(`The connection "${originalConnectionId}" has been updated to "${connectionContext.connectionId}".`);
            });
        }
        function addConnectionListeners(connection) {
            // Add listeners on the connection object.
            connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);
            connection.on(ConnectionEvents.disconnected, disconnected);
            connection.on(ConnectionEvents.protocolError, protocolError);
            connection.on(ConnectionEvents.error, error);
        }
        function cleanConnectionContext(connectionContext) {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove listeners from the connection object.
                connectionContext.connection.removeListener(ConnectionEvents.connectionOpen, onConnectionOpen);
                connectionContext.connection.removeListener(ConnectionEvents.disconnected, disconnected);
                connectionContext.connection.removeListener(ConnectionEvents.protocolError, protocolError);
                connectionContext.connection.removeListener(ConnectionEvents.error, error);
                // Close the connection
                yield connectionContext.connection.close();
            });
        }
        addConnectionListeners(connectionContext.connection);
        log.connectionCtxt("[%s] Created connection context successfully.", connectionContext.connectionId);
        return connectionContext;
    }
    ConnectionContext.create = create;
})(ConnectionContext || (ConnectionContext = {}));
//# sourceMappingURL=connectionContext.js.map